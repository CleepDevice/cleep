#!/usr/bin/env python
# -*- coding: utf-8 -*-

from raspiot.utils import InvalidParameter, MissingParameter, CommandError
from raspiot.libs.configs.config import Config
from raspiot.libs.internals.console import Console
import logging
import os
import re
import io

class WpaSupplicantConf(Config):
    """
    Helper class to update and read /etc/wpa_supplicant/wpa_supplicant.conf file

    Infos:
        https://w1.fi/cgit/hostap/plain/wpa_supplicant/wpa_supplicant.conf
    """

    CONF = u'/etc/wpa_supplicant/wpa_supplicant.conf'

    ENCRYPTION_TYPE_WPA = u'wpa'
    ENCRYPTION_TYPE_WPA2 = u'wpa2'
    ENCRYPTION_TYPE_WEP = u'wep'
    ENCRYPTION_TYPE_UNSECURED = u'unsecured'
    ENCRYPTION_TYPE_UNKNOWN = u'unknown'
    ENCRYPTION_TYPES = [ENCRYPTION_TYPE_WPA, ENCRYPTION_TYPE_WPA2, ENCRYPTION_TYPE_WEP, ENCRYPTION_TYPE_UNSECURED, ENCRYPTION_TYPE_UNKNOWN]

    def __init__(self, cleep_filesystem, filepath=None, backup=True):
        """
        Constructor

        Args:
            cleep_filesystem (CleepFilesystem): CleepFilesystem instance
            filepath (string): if you want to specify another file than /etc/wpa_supplicant/wpa_supplicant.conf.
            backup (bool): backup file
        """
        if filepath is None:
            filepath = self.CONF
        Config.__init__(self, cleep_filesystem, filepath, None, backup)

        #logger
        self.logger = logging.getLogger(self.__class__.__name__)
        #self.logger.setLevel(logging.DEBUG)

        #members
        self.cleep_filesystem = cleep_filesystem
        self.groups = {}

    def encrypt_password(self, network, password):
        """
        Encrypt specified password using wpa_passphrase

        Args:
            network (string): network name
            password (string): password to encrypt

        Return:
            string: encrypted password
        """
        if network is None or len(network)==0:
            raise MissingParameter(u'Parameter network is missing')
        if password is None or len(password)==0:
            raise MissingParameter(u'Parameter password is missing')
        if len(password)<8 or len(password)>63:
            raise InvalidParameter(u'Parameter password must be 8..63 string length')

        c = Console()
        res = c.command(u'/usr/bin/wpa_passphrase "%s" "%s"' % (network, password))
        if res[u'error'] or res[u'killed']:
            self.logger.error(u'Error with password: %s' % u''.join(res[u'stderr']))
            raise Exception(u'Error with password: unable to encrypt it')
        if not ''.join(res[u'stdout']).startswith(u'network'):
            self.logger.error(u'Error with password: %s' % u''.join(res[u'stdout']))
            raise Exception(u'Error with password: %s' % u''.join(res[u'stdout']))

        for line in res[u'stdout']:
            line = line.strip()
            if line.startswith(u'psk='):
                return line.replace(u'psk=', '')

        self.logger.error(u'No password generated by wpa_passphrase: %s' % res)
        raise Exception(u'No password generated by wpa_passphrase command')

    def wpa_passphrase(self, network, password):
        """
        Execute wpa_passphrase command and return output

        Args:
            network (string): network name
            password (string): password

        Return:
            list: wpa_passphrase output without password in clear
        """
        if network is None or len(network)==0:
            raise MissingParameter(u'Parameter network is missing')
        if password is None or len(password)==0:
            raise MissingParameter(u'Parameter password is missing')
        if len(password)<8 or len(password)>63:
            raise InvalidParameter(u'Parameter password must be 8..63 string length')

        c = Console()
        res = c.command(u'/usr/bin/wpa_passphrase "%s" "%s"' % (network, password))
        if res[u'error'] or res[u'killed']:
            self.logger.error(u'Error with password: %s' % u''.join(res[u'stderr']))
            raise Exception(u'Error with password: unable to encrypt it')
        if not ''.join(res[u'stdout']).startswith(u'network'):
            self.logger.error(u'Error with password: %s' % u''.join(res[u'stdout']))
            raise Exception(u'Error with password: %s' % u''.join(res[u'stdout']))
        output = [line+u'\n' for line in res[u'stdout'] if not line.startswith(u'\t#psk=')]

        return output

    def get_configurations(self):
        """
        Return networks found in conf file
        """
        networks = {}
        entries = []

        results = self.find(r'network\s*=\s*\{\s*(.*?)\s*\}', re.UNICODE | re.DOTALL)
        for group, groups in results:
            #prepare values
            ssid = None

            #filter none values
            groups = filter(None, groups)

            #create new entry
            current_entry = {
                u'group': group, #DO NOT REMOVE IT, field is removed at end of this function
                u'network': None,
                u'psk': None,
                u'hidden': False,
                u'encryption': self.ENCRYPTION_TYPE_WPA2, #default encryption to WPA2 event if not specified in wpa_supplicant.conf file
                u'disabled': False
            }
            entries.append(current_entry)

            #fill entry
            pattern = r'^\s*(\w+)=(.*?)\s*$'
            for content in groups:
                sub_results = self.find_in_string(pattern, content, re.UNICODE | re.MULTILINE)
                
                #filter none values
                for sub_group, sub_groups in sub_results:
                    if len(sub_groups)==2:
                        if sub_groups[0].startswith(u'ssid'):
                            current_entry[u'network'] = sub_groups[1].replace('"','').replace('\'','')
                        elif sub_groups[0].startswith(u'scan_ssid'):
                            if sub_groups[1] is not None and sub_groups[1].isdigit() and sub_groups[1]=='1':
                                current_entry[u'hidden'] = True
                        elif sub_groups[0].startswith(u'key_mgmt'):
                            if sub_groups[1]==u'WPA-PSK':
                                current_entry[u'encryption'] = self.ENCRYPTION_TYPE_WPA2
                            elif sub_groups[1]==u'NONE':
                                current_entry[u'encryption'] = self.ENCRYPTION_TYPE_WEP
                        elif sub_groups[0].startswith(u'psk'):
                            current_entry[u'psk'] = sub_groups[1].replace('"','').replace('\'','')
                        elif sub_groups[0].startswith(u'disabled') and sub_groups[1]=='1':
                            current_entry[u'disabled'] = True

                    else:
                        #invalid content, drop this item
                        continue

        self.groups = {}
        for entry in entries:
            self.groups[entry[u'network']] = entry[u'group']
            del entry[u'group']
            networks[entry[u'network']] = entry

        return networks

    def get_configuration(self, network):
        """
        Get network config

        Args:
            network (string): network name

        Returns:
            dict: network config, None if network is not found
        """
        configurations = self.get_configurations()

        if network in configurations.keys():
            return configurations[network]

        return None

    def delete_network(self, network):
        """
        Delete network from config

        Args:
            network (string): network name

        Returns:
            bool: True if network deleted, False otherwise
        """
        #check params
        if network is None or len(network)==0:
            raise MissingParameter(u'Network parameter is missing')

        #check if network exists
        configuration = self.get_configuration(network)
        if configuration is None:
            return False

        return self.remove(self.groups[configuration[u'network']])

    def __add_network(self, config):
        """
        Add new entry based on configuration

        Args:
            config (dict): configuration dict (see get_configuration)

        Return:
            bool: True if network added
        """
        content = [
            u'\nnetwork={\n',
            u'\tssid="%s"\n' % config[u'network']
        ]
        if config[u'encryption']!=self.ENCRYPTION_TYPE_UNSECURED:
            content.append(u'\tpsk=%s\n' % config[u'psk'])
        if config[u'hidden']:
            content.append(u'\tscan_ssid=1\n')
        if config[u'disabled']:
            content.append(u'\tdisabled=1\n')
        content.append(u'}\n')

        self.logger.debug('Config to append %s' % content)

        return self.add_lines(content)

    def add_network(self, network, encryption, password, hidden=False):
        """
        Add new network in config file
        Password is automatically encrypted using wpa_passphrase
        
        Args:
            network (string): network name (ssid)
            encryption (string): network encryption (wpa|wpa2|wep|unsecured)
            password (string): network password (not encrypted!)
            hidden (bool): hidden network flag

        Raises:
            MissingParameter, InvalidParameter
        """
        #check params
        if network is None or len(network)==0:
            raise MissingParameter(u'Parameter "network" is missing')
        if encryption is None or len(encryption)==0:
            raise MissingParameter(u'Parameter "encryption" is missing')
        if encryption not in self.ENCRYPTION_TYPES:
            raise InvalidParameter(u'Encryption "%s" does not exist (available: %s)' % (encryption, u','.join(self.ENCRYPTION_TYPES)))
        if encryption!=self.ENCRYPTION_TYPE_UNSECURED and (password is None or len(password)==0):
            raise MissingParameter(u'Parameter "password" is missing')

        #check if network doesn't already exist
        if self.get_configuration(network) is not None:
            raise InvalidParameter(u'Network "%s" is already configured' % network)
    
        #header
        output = [
            u'\nnetwork={\n',
            u'\tssid="%s"\n' % network,
        ]

        #inject hidden param if necessary
        if hidden:
            output.append(u'\tscan_ssid=1\n')

        #inject network type and password
        if encryption in [self.ENCRYPTION_TYPE_WPA, self.ENCRYPTION_TYPE_WPA2]:
            #WPA/WPA2 security
            output.append(u'\tkey_mgmt=WPA-PSK\n')
            output.append(u'\tpsk=%s\n' % password)
        elif encryption==self.ENCRYPTION_TYPE_WEP:
            #WEP security
            output.append(u'\tkey_mgmt=NONE\n')
            output.append(u'\twep_key0=%s\n' % password)
            output.append(u'\twep_tx_keyidx=0\n')
        else:
            #unsecured network
            output.append(u'\tkey_mgmt=NONE\n')

        #footer
        output.append(u'}\n')

        #write new network config
        return self.add_lines(output)

    def update_network_password(self, network, password):
        """
        Update specified network password

        Args:
            network (string): network name (ssid)
            password (string): network password

        Raises:
            MissingParameter
        """
        #check params
        if network is None or len(network)==0:
            raise MissingParameter(u'Parameter network is missing')
        if password is None or len(password)==0:
            raise MissingParameter(u'Parameter password is missing')

        #first of all get network configuration
        config = self.get_configuration(network)
        self.logger.debug(config)
        if config is None:
            return False

        #encrypt password if necessary
        if config[u'encryption'] in (self.ENCRYPTION_TYPE_WPA2, self.ENCRYPTION_TYPE_WPA):
            config[u'psk'] = self.encrypt_password(network, password)
            self.logger.debug('Encrypt password %s: %s' % (password, config[u'psk']))
        else:
            config[u'psk'] = password

        #delete existing entry
        if self.delete_network(network):
            self.logger.debug('Config deleted')
            #and add new updated entry
            return self.__add_network(config)

        return False

    def __update_network_disabled_flag(self, network, disabled):
        """
        Update specified network disabled flag

        Args:
            network (string): network name (ssid)
            disabled (bool): disabled flag
        """
        #check params
        if network is None or len(network)==0:
            raise MissingParameter(u'Parameter network is missing')
        if disabled is None:
            raise MissingParameter(u'Parameter disabled is missing')

        #first of all get network configuration
        config = self.get_configuration(network)
        if config is None:
            return False

        #update disabled flag
        config[u'disabled'] = disabled

        #delete existing entry
        if self.delete_network(network):
            #and add new updated entry
            return self.__add_network(config)

        return False

    def enable_network(self, network):
        """
        Enable network

        Args:
            network (string): network name

        Raises:
            MissingParameter
        """
        return self.__update_network_disabled_flag(network, False)

    def disable_network(self, network):
        """
        Disable network

        Args:
            network (string): network name

        Raises:
            MissingParameter
        """
        return self.__update_network_disabled_flag(network, True)

    def connect_network(self, interface, network):
        """
        Connect interface to specified network

        Args:
            interface (string): interface name
            network (string): network name

        Return:
            bool: True if connection succeed
        """
        #kill wpa_supplicant daemon instance
        c = Console()
        res = c.command(u'/usr/bin/pkill -f "wpa_supplicant.*%s"' % interface)
        if res[u'error'] or res[u'killed']:
            self.logger.error(u'Command pkill failed')
            return False
        if res.get_last_return_code()!='0':
            self.logger.warning(u'wpa_supplicant daemon seems not running on interface %s' % interface)

        #get conf for specified interface
        config = self.get_configuration(interface)
        if config is None:
            self.logger.warning('No configuration found for network %s' % network)
            return False

        #generate temp config file
        conf_path = u'/tmp/%s_wpa_supplicant.conf' % interface
        if os.path.exists(conf_path):
            try:
                os.remove(conf_path)
            except:
                self.logger.exception(u'Unable to delete conf file %s' % conf_path)
                return False
        try:
            conf_file = io.open(conf_path, u'w')
            conf_file.write(u'network={\n\tssid="%s"\n\tpsk="%s"\n}\n' % (network, config[u'psk']))
            conf_file.close()
        except:
            self.exception(u'Unable to open conf file %s:' % conf_path)
            return False

        #launch new wpa_supplicant instance with new parameters
        res = c.command(u'/sbin/wpa_supplicant -i %s -B -Dwext,nl80211 -c %s' (interface, conf_path))
        if res[u'stdout'] or res[u'stderr']:
            self.logger.error(u'Unable to launch new wpa_supplicant instance on interface %s: %s' % (interface, res))
            return False

        return True

    def write_fake_wpasupplicant(self, path, network, encryption, password, hidden=False):
        """
        Write fake wpa_supplicant.conf content to specified file
        This is useful to test a connection specifying new network infos

        Args:
            network (string): network name (ssid)
            encryption (string): network encryption (wpa|wpa2|wep|unsecured)
            password (string): network password
            hidden (bool): hidden network flag

        Returns:
            bool: True if file generated, False otherwise
        """
        #check params
        if path is None or len(path)==0:
            raise MissingParameter(u'Parameter path is missing')
        if encryption is None or len(encryption)==0:
            raise MissingParameter(u'Parameter encryption is missing')
        if encryption not in self.ENCRYPTION_TYPES:
            raise InvalidParameter(u'Encryption "%s" does not exist (available: %s)' % (encryption, u','.join(self.ENCRYPTION_TYPES)))
        if encryption!=self.ENCRYPTION_TYPE_UNSECURED and (password is None or len(password)==0):
            raise MissingParameter(u'Parameter "password" is missing')
        if network is None or len(network)==0:
            raise MissingParameter(u'Parameter network is missing')
        if encryption!=self.ENCRYPTION_TYPE_UNSECURED and (len(password)<8 or len(password)>63):
            raise InvalidParameter(u'Parameter password must be 8..63 string length')

        #write header
        with io.open(path, u'w') as fd:
            content  = u'country=GB\n'
            content += u'ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\n'
            content += u'update_config=1\n'
            fd.write(content)
        self.logger.debug('Written fake wpa_supplicant.conf file to %s' % path)

        #create new wpasupplicant instance
        instance = WpaSupplicantConf(self.cleep_filesystem, path, backup=False)

        #add new network
        if not instance.add_network(network, encryption, password, hidden):
            self.logger.error('Failed to write temp wpa_supplicant.conf file %s' % path)
            return False

        return True


