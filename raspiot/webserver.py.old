#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
from multiprocessing import Process
import time
import logging
import os
import json
import probes
import outputs
import zones
import modes
import schedules
#import agocontrol
#webserver
import mimetypes
import cgi
import BaseHTTPServer
#websocket
#from autobahn.twisted.websocket import WebSocketServerProtocol, WebSocketServerFactory, listenWS
#from twisted.internet import reactor, ssl
#from twisted.web.server import Site
#from twisted.web.static import File

HOST_NAME = '0.0.0.0'
WEBSERVER_PORT = 80
#WEBSOCKET_PORT = 9000
BASE_DIR = '/var/opt/mythermostat/html/'
MAIN_PAGE = "index.html"

PROBES = None
OUTPUTS = None
ZONES = None
MODES = None
SCHEDULES = None
AGO = None

#logging.basicConfig(filename='agosqueezebox.log', level=logging.INFO, format="%(asctime)s %(levelname)s : %(message)s")
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s %(name)s %(levelname)s : %(message)s")
logger = logging.getLogger(__name__)

class ThermostatHandler(BaseHTTPServer.BaseHTTPRequestHandler):

    """=========== UTILS ============="""
    def parseJson(self, headers, data):
        output = None
        try:
            length = int(headers.getheader('content-length'))
            js = data.read(length)
            output = json.loads(js)
        except:
            logger.exception('Failed to decode posted data:')
        return output

    def parsePost(self, headers, data):
        """parse data from POST"""
        output = cgi.FieldStorage(
                fp=temp, 
                headers=headers,
                environ={'REQUEST_METHOD':'POST', 'CONTENT_TYPE':self.headers['Content-Type'], })
        return output

    def dictToList(self, d):
        """convert dict to list
           dict key is inserted in dict item as id"""
        l = []
        try:
            if not isinstance(d, dict):
                #not a dict!
                logger.fatal('dictToList: Unable to convert non dict variable')
                logger.debug('%s = %s' % (type(d), str(d)))
            else:
                for key in d:
                    if isinstance(d[key], dict):
                        tmp = d[key]
                    else:
                        tmp = {}
                        tmp['value'] = d[key]
                    tmp['key'] = key
                    l.append(tmp)
        except:
            logger.exception('dictToList exception:')
            logger.debug('%s = %s' % (type(d), str(d)))
        return l


    """=========== URI ============="""
    def do_API(self):
        """handle /api uri"""
        logger.debug('do_API')

    def do_COMMAND(self, data):
        """handle /command uri"""
        logger.debug('COMMAND data:%s' % str(data))
        resp = {'error':False, 'msg':'', 'more':{}}
        if len(data)>0 and isinstance(data, dict) and data.has_key('command'):
            #polling
            """if data['command']=='poll':
                logger.info('polling starts...')
                time.sleep(15)
                logger.info('polling ends...')"""
            #probes commands
            if data['command']=='getprobes':
                (resp['error'], resp['msg'], more) = PROBES.getProbes()
                resp['more'] = self.dictToList(more)
            elif data['command']=='scanprobes':
                (resp['error'], resp['msg'], more) = PROBES.scanLocalProbes()
                resp['more'] = self.dictToList(more)
            elif data['command']=='enableprobe':
                (resp['error'], resp['msg'], resp['more']) = PROBES.enableProbe(data['uuid'])
            elif data['command']=='disableprobe':
                (resp['error'], resp['msg'], resp['more']) = PROBES.disableProbe(data['uuid'])
            elif data['command']=='setprobename':
                (resp['error'], resp['msg'], resp['more']) = PROBES.setProbeName(data['uuid'], data['name'])
            #outputs commands
            elif data['command']=='getgpios':
                (resp['error'], resp['msg'], resp['more']) = OUTPUTS.getGpios()
            elif data['command']=='getoutputs':
                (resp['error'], resp['msg'], more) = OUTPUTS.getOutputs()
                resp['more'] = self.dictToList(more)
            elif data['command']=='setoutputs':
                (resp['error'], resp['msg'], resp['more']) = OUTPUTS.setOutputs(data['outputs'])
            elif data['command']=='turnon':
                (resp['error'], resp['msg'], resp['more']) = OUTPUTS.turnOn(data['id'], data['gpio'])
            elif data['command']=='turnoff':
                (resp['error'], resp['msg'], resp['more']) = OUTPUTS.turnOff(data['id'], data['gpio'])
            #zones commands
            elif data['command']=='getzones':
                (resp['error'], resp['msg'], more) = ZONES.getZones()
                resp['more'] = self.dictToList(more)
            elif data['command']=='setzones':
                (resp['error'], resp['msg'], resp['more']) = ZONES.setZones(data['zones'])
            #modes commands
            elif data['command']=='getmodes':
                (resp['error'], resp['msg'], more) = MODES.getModes()
                resp['more'] = self.dictToList(more)
            elif data['command']=='setmodes':
                (resp['error'], resp['msg'], resp['more']) = MODES.setModes(data['modes'])
            #schedules commands
            elif data['command']=='getschedules':
                (resp['error'], resp['msg'], more) = SCHEDULES.getSchedules()
                resp['more'] = self.dictToList(more)
            elif data['command']=='setschedules':
                (resp['error'], resp['msg'], more) = SCHEDULES.setSchedules(data['zone'], data['schedules'])
                resp['more'] = self.dictToList(more)
            #config
            elif data['command']=='getconfig':
                (resp['error'], resp['msg'], probes) = PROBES.getProbes()
                (resp['error'], resp['msg'], gpios) = OUTPUTS.getGpios()
                (resp['error'], resp['msg'], outputs) = OUTPUTS.getOutputs()
                (resp['error'], resp['msg'], zones) = ZONES.getZones()
                (resp['error'], resp['msg'], modes) = MODES.getModes()
                (resp['error'], resp['msg'], schedules) = SCHEDULES.getSchedules()
                resp['more'] = {}
                resp['more']['probes'] = self.dictToList(probes)
                resp['more']['gpios'] = gpios
                resp['more']['outputs'] = self.dictToList(outputs)
                resp['more']['zones'] = self.dictToList(zones)
                resp['more']['modes'] = self.dictToList(modes)
                resp['more']['schedules'] = self.dictToList(schedules)
            #agocontrol
            elif data['command']=='getsensors':
                pass
            elif data['command']=='getmonitoredsensors':
                pass
            #error
            else:
                resp['error'] = True
                resp['msg'] = 'Unknow command [%s]' % data['command']
        else:
            #nothing specified in command
            resp['error'] = True
            resp['msg'] = 'No handler or command parameter specified'
        return resp

    def do_SERVEFILES(self):
        """serve local files"""
        #server local files
        if self.path=='/':
            #handle main page
            p = os.path.join(BASE_DIR, MAIN_PAGE)
        else:
            if self.path[0]=='/':
                p = os.path.join(BASE_DIR, self.path[1:])
            else:
                p = os.path.join(BASE_DIR, self.path)
        #logger.debug('serve local files [%s]' % p)
        if os.path.exists(p):
            #mime type
            (_, e) = os.path.splitext(p)
            #logger.debug('ext [%s]' % e)
            if mimetypes.types_map.has_key(e):
                m = mimetypes.types_map[e]
            else:
                m = 'application/octet-stream'
            #logger.debug('mime type=%s' % m)

            #open file
            f = open(p)
            self.send_response(200)
            self.send_header("Content-type", m)
            self.end_headers()
            self.wfile.write(f.read())
            f.close()
        else:
            self.send_error(404,'File Not Found: %s' % self.path)


    """=========== HTTP ============="""
    def do_HEAD(self):
        #TODO useful ?
        logger.debug("do_HEAD")
        s.send_response(200)
        s.send_header("Content-type", "text/html")
        s.end_headers()
        return

    def do_GET(self):
        """Respond to a GET request."""
        #logger.debug("do_GET [%s]" % self.path)
        if self.path.startswith('/api'):
            pass
        else:
            self.do_SERVEFILES()

        return

    def do_POST(self):
        #prepare response
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()

        if self.path.startswith('/command'):
            data = self.parseJson(self.headers, self.rfile)
            resp = self.do_COMMAND(data)
            self.wfile.write('%s\n' % json.dumps(resp))

        return

class ThermostatProtocol(WebSocketServerProtocol):
    def onConnect(self, request):
        logger.info("Client connecting: {0}".format(request.peer))

    def onOpen(self):
        logger.info("WebSocket connection open.")

    def onMessage(self, payload, isBinary):
        if isBinary:
            logger.info("Binary message received: {0} bytes".format(len(payload)))
        else:
            logger.info("Text message received: {0}".format(payload.decode('utf8')))
        #self.sendMessage(payload, isBinary)

    def onClose(self, wasClean, code, reason):
        logger.info("WebSocket connection closed: {0}".format(reason))

"""
def runWebsocket():
    factory = WebSocketServerFactory(u"wss://%s:%d" % (HOST_NAME, WEBSOCKET_PORT), debug=False)
    factory.protocol = ThermostatProtocol
    reactor.listenTCP(WEBSOCKET_PORT, factory)
    logger.info("Websocket started - %s:%d" % (HOST_NAME, WEBSOCKET_PORT))
    reactor.run()
"""

if __name__ == '__main__':
    PROBES = probes.Probes()
    OUTPUTS = outputs.Outputs()
    ZONES = zones.Zones()
    MODES = modes.Modes()
    SCHEDULES = schedules.Schedules()
    #AGO = agocontrol.Agocontrol()

    #websocket
    """p = Process(target=runWebsocket)
    p.start()

    #webserver
    mimetypes.init()
    httpd = BaseHTTPServer.HTTPServer((HOST_NAME, WEBSERVER_PORT), ThermostatHandler)
    logger.info("Webserver started - %s:%d" % (HOST_NAME, WEBSERVER_PORT))
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
    httpd.server_close()

    p.terminate()"""

    """
    from twisted.python import log
    log.startLogging(sys.stdout)

    contextFactory = ssl.DefaultOpenSSLContextFactory('server.key', 'server.crt')
    factory = WebSocketServerFactory(u"wss://%s:%d" % (HOST_NAME, WEBSOCKET_PORT), debug=True)
    factory.protocol = ThermostatProtocol
    listenWS(factory, contextFactory)

    webdir = File(BASE_DIR)
    webdir.contentTypes['.crt'] = 'application/x-x509-ca-cert'
    web = Site(webdir)
    reactor.listenTCP(WEBSERVER_PORT, web)
    reactor.run()
    """

    PROBES.stop()
    logger.info("Server stopped")

